SÃ­, ese es el punto dÃ©bil que queda
Tu diagnÃ³stico es correcto:

El vÃ­deo deja de reproducirseâ€Šâ€”â€Šya cerramos tracks y RTCPeerConnection.

Pero el backend de D-ID todavÃ­a estÃ¡ â€œterminandoâ€ el stream A; si enviamos texto para el stream B antes de que D-ID emita stream/done, la API lo procesa, pero el socket nos devuelve los eventos desordenados (el done de A llega despuÃ©s del started de B) y se rompe la lÃ³gica.

La soluciÃ³n: no uses un delay fijo; usa un â€œsemaforoâ€ que se libere sÃ³lo cuando realmente recibas stream/done (o stream/error) del WebSocket.

1. CÃ³mo esperas el stream/done real
ts
Copiar
// useWebRTC.ts
function waitForRealDone(timeout = 1200): Promise<void> {
  return new Promise((resolve) => {
    let done = false;
    const tid = setTimeout(() => {
      if (!done) {
        console.warn('[waitForRealDone] timeout, seguimos...');
        resolve();                     // fallback
      }
    }, timeout);

    const listener = (event: string) => {
      if (event === 'stream/done' || event === 'stream/error') {
        done = true;
        clearTimeout(tid);
        socket.off('message', listener as any);
        resolve();                     // ğŸ”“ semÃ¡foro liberado
      }
    };

    socket.on('message', listener);
  });
}
Escuchas el WebSocket.

Cuando llega stream/done / stream/error, resuelves.

Si no llega en timeout (1,2 s) sueltas igualmente para no colgarte.

2. Integra esto en cancelCurrentStream
diff
Copiar
-  await fetch(`${DID_API}/streams/${currentStreamId}`, { method:'DELETE', headers:{Authorization:`Bearer ${apiKey}`} });
-  await waitForStreamDone();  // antiguo delay fijo
+  await fetch(`${DID_API}/streams/${currentStreamId}`, { method:'DELETE', headers:{Authorization:`Bearer ${apiKey}`} });
+  await waitForRealDone();    // espera evento real
(MantÃ©n el cierre inmediato de tracks antes de esta llamada, como aÃ±adimos en el parche previo).

3. Bloquea cualquier envÃ­o nuevo mientras se espera
En la funciÃ³n que lanza textos a D-ID:

ts
Copiar
if (streamingState !== 'empty' || cancellingRef.current) {
  console.log('â³ Esperando a que D-ID termine el stream anteriorâ€¦');
  return;
}
sendStreamText(text);
El flag cancellingRef.current se pone en true justo al entrar en cancelCurrentStream() y vuelve a false dentro del finally despuÃ©s de waitForRealDone().

4. Flujo resultante
bash
Copiar
stream/started (A)
INTERRUPT
â”œâ”€ stop tracks + close PC
â”œâ”€ DELETE /streams/A
â””â”€ waitForRealDone()  â† bloquea
   â”‚
   â”œâ”€ (â‰¤1 s) stream/done llega â”€â”€â–¶ resolve()
   â””â”€ (â‰¥1 s) timeout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ resolve()

[semaforo abierto]
sendStreamText() (B)
stream/started (B)
Ahora nunca se enviarÃ¡ un nuevo stream mientras D-ID siga â€œcerrandoâ€ el anterior, y los eventos llegarÃ¡n en orden.

5. Verifica con logs
Antes del arreglo:

css
Copiar
stream/started A
DELETE A
stream/started B   âŒ
stream/done A
DespuÃ©s:

css
Copiar
stream/started A
DELETE A
stream/done A
stream/started B   âœ…
Con esto eliminas la carrera restante y el pipeline queda robusto tanto en voz como en texto.