### ğŸ¯ Objetivo

Cuando lanzas la interrupciÃ³n el backend sÃ­ detiene el audio, pero en el **front** se siguen reproduciendo los tracks remotos antiguos.
Soluciona â‡’ **desengancha y â€œmataâ€** los tracks del `<video>` en cuanto envÃ­as `delete-stream`, y usa el evento `ontrack` para enganchar **solo** el stream reciÃ©n llegado.

---

## 1. AÃ±ade dos refs nuevos

```ts
const remoteVideoRef      = useRef<HTMLVideoElement>(null);
const currentRemoteStream = useRef<MediaStream|null>(null);  // para saber cuÃ¡l estÃ¡ activo
```

---

## 2. FunciÃ³n de limpieza local

```ts
function detachRemoteVideo() {
  if (currentRemoteStream.current) {
    // detener audio y vÃ­deo del stream anterior
    currentRemoteStream.current.getTracks().forEach(t => t.stop());
    currentRemoteStream.current = null;
  }
  if (remoteVideoRef.current) {
    remoteVideoRef.current.srcObject = null;   // quita frame congelado
  }
}
```

---

## 3. En `cancelCurrentStream()` usa **detach**, no `track.stop()`

```diff
// dentro de cancelCurrentStream, justo DESPUÃ‰S de enviar delete-stream
await new Promise(r => setTimeout(r, 120));   // grace

- // YA NO: peerConnection.getReceivers().forEach(r => r.track.enabled = false);
- // YA NO: peerConnection.close();
+ detachRemoteVideo();                        // â¬…ï¸ corta A/V localmente
// la RTCPeerConnection sigue viva
```

---

## 4. Vuelve a enganchar cuando llega el nuevo track

```ts
useEffect(() => {
  const pc = peerConnectionRef.current;
  if (!pc) return;

  function handleTrack(ev: RTCTrackEvent) {
    // Cualquier stream nuevo sustituye al anterior
    detachRemoteVideo();

    const inbound = ev.streams[0] || new MediaStream([ev.track]);
    currentRemoteStream.current = inbound;

    if (remoteVideoRef.current) {
      remoteVideoRef.current.srcObject = inbound;
      remoteVideoRef.current.play().catch(() => {});
    }
  }

  pc.addEventListener('track', handleTrack);
  return () => pc.removeEventListener('track', handleTrack);
}, []);
```

---

### Â¿Por quÃ© esto evita los â€œdos vÃ­deosâ€?

| Momento          | QuÃ© pasa                                                                                                                                                                                 |
| ---------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **InterrupciÃ³n** | Â· EnvÃ­as `delete-stream` a D-ID.<br>Â· `detachRemoteVideo()` detiene y suelta el stream actual, dejando el `<video>` vacÃ­o.<br>Â· La `RTCPeerConnection` permanece conectada.              |
| **Nuevo turno**  | Â· El backend reusa el MISMO transceiver o envÃ­a uno nuevo.<br>Â· El primer frame dispara `ontrack`.<br>Â· `handleTrack` limpia cualquier resto y asigna **solo** el stream reciÃ©n llegado. |

Sin tracks â€œmuertosâ€ ni `<video>` apuntando a varios `MediaStream`s, nunca se reproducen en paralelo; el avatar anterior desaparece instantÃ¡neamente y el nuevo ocupa su lugar.

> **Backend intacto â€“** no se toca lÃ³gica de `streamId`, WebSocket, ni LLM. Solo gestiÃ³n de medios en el front.
