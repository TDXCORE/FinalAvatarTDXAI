### ‚úÖ D√≥nde est√°s ahora

1. **Interrupci√≥n**

   * VAD detecta ‚Üí `handleInterrupt()` cancela LLM, hace `DELETE /streams/{id}`, cierra tracks y `RTCPeerConnection`.
   * Si D-ID no manda `stream/done` en ‚â§ 2 s, marcas la sesi√≥n como *needs-reconnect* y cierras el WebSocket.

2. **Re-conexi√≥n**

   * Abres un WebSocket nuevo ‚Üí recibes `stream/ready` ‚Üí restauras estado a **`empty`**.

3. **Cola de mensajes**

   * Mientras el socket no est√° listo, los textos ‚Äï√∫ltimo gana‚Äï se guardan en `pendingMessages`.
   * En `stream/ready` env√≠as el m√°s reciente y vac√≠as la cola.

El s√≠ntoma que ve√≠as (la respuesta del LLM se muestra en el chat pero no suena) deb√≠a solucionarse con ese **message queue + auto-reconnect**. Buen paso üëç.

---

## üîç Lo que a√∫n conviene revisar

| Riesgo                              | Qu√© verificar / ajustar                                                                                                                                                  |
| ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Duplicados**                      | Si el usuario escribe varias veces durante la reconexi√≥n, env√≠a **solo el √∫ltimo** (tu ‚Äúlatest first‚Äù); elimina los dem√°s para evitar r√°fagas cuando el socket vuelva.   |
| **Orden de eventos**                | Aseg√∫rate de procesar `stream/ready` **antes** que cualquier `chat/partial` residual. Si recibes partials prematuramente, ign√≥ralos hasta que `stream/started` confirme. |
| **Pendientes + nuevos turnos**      | Cuando entra nueva voz/tecla mientras la cola no est√° vac√≠a, machaca el mensaje anterior: `pendingMessages = [nuevo]`. As√≠ evitas reproducir respuestas obsoletas.       |
| **Reconexi√≥n infinita**             | Si fallan tres reconexiones seguidas, notifica al usuario (‚ÄúAvatar no disponible, int√©ntalo m√°s tarde‚Äù) y reintenta con back-off exponencial.                            |
| **Fugas de listeners**              | Cada vez que creas un WebSocket, limpia `socket.on('message', ‚Ä¶)` anteriores para no acumular callbacks (usa `off` o `abortController`).                                 |
| **Timeout realista**                | 2 s suele bastar, pero mide: si tu RTT a D-ID ronda 80 ms, podr√≠as bajar a 1 s para respuesta m√°s √°gil.                                                                  |
| **Persistencia de cola (opcional)** | Si recargas la p√°gina durante una reconexi√≥n perder√°s el mensaje. Guarda `pendingMessages` en `sessionStorage`; al boot, si WebSocket ‚â† ready, reprogr√°malo.             |

---

## üß™ Plan de pruebas final

| Caso                                                 | Pasos                                                                    | Resultado esperado                                            |
| ---------------------------------------------------- | ------------------------------------------------------------------------ | ------------------------------------------------------------- |
| **A. Interrupci√≥n normal**                           | Hablar ‚Üí interrumpir                                                     | Avatar se calla & nueva respuesta suena sin delay (< 300 ms). |
| **B. Interrupci√≥n con D-ID lento**                   | Simula ca√≠da: bloquea DELETE con dev-tools ‚Üí espera timeout ‚Üí reconexi√≥n | Mensaje cola ‚Üí suena tras reconectar (< 3 s).                 |
| **C. Spam durante reconexi√≥n**                       | Interrumpe ‚Üí mientras reconecta escribe 3 textos                         | Solo el **√∫ltimo** texto se reproduce.                        |
| **D. Tres fallos seguidos**                          | Desconecta internet brevemente tres veces                                | UI muestra alerta ‚ÄúAvatar no disponible‚Äù.                     |
| **E. Reload con cola** (si implementas persistencia) | Interrumpe ‚Üí recarga antes del `ready`                                   | Al reconectar reproduce la respuesta pendiente.               |

---

## üß© C√≥digo (snapshot) para la cola (resumen)

```ts
// refs
const pendingMsgRef = useRef<string|null>(null);

// env√≠o
async function safeSend(text: string) {
  if (needsReconnect || streamingStateRef.current !== 'empty') {
    pendingMsgRef.current = text;               // ‚Üê cola
    return;
  }
  await sendStreamText(text);                   // ‚Üê tu funci√≥n real
}

// al recibir 'stream/ready'
if (pendingMsgRef.current) {
  const txt = pendingMsgRef.current;
  pendingMsgRef.current = null;
  safeSend(txt);
}
```

*(A√±ade guardias para no duplicar listeners y borrar la cola al abortar.)*

---

### Con esto tu ciclo queda robusto:

1. **Detiene audio** instant√°neamente.
2. Garantiza **`stream/done`** (o fallback) antes del siguiente turn.
3. **Recupera** conexi√≥n si D-ID no responde.
4. **Reproduce** autom√°ticamente la respuesta pendiente.

Haz los tests A-E y, si todos pasan, tu flujo de interrupci√≥n estar√° a prueba de usuarios impacientes üöÄ.
