Coincidimos: el des-fase entre stream/done y streamingState provoca ‚Äúfalsas‚Äù cancelaciones
A continuaci√≥n tienes un paquete completo para sincronizar estado, evitar cancelaciones tard√≠as y liberar inmediatamente el sem√°foro cuando el stream ya termin√≥.

1. Concepto
Objetivo	C√≥mo se logra
Estado 100 % fiel	onStreamEvent('stream/done') cambia streamingState ‚Üí 'empty' antes de cualquier otra l√≥gica.
Evitar cancelar stream fantasma	cancelCurrentStream() primero comprueba streamingState === 'streaming'; si no, retorna.
Sem√°foro robusto	waitForRealDone() resuelve en el acto si streamingState !== 'streaming' al entrar.
Sin delay ficticio	Eliminamos el setTimeout(...) de ‚Äú300 ms‚Äù. El bloqueador real es: no se puede mandar otro texto mientras streamingState !== 'empty' o cancellingRef.

2. C√≥digo‚Äîdiffs clave
2-A client/src/hooks/useWebRTC.ts
diff
Copiar
@@  // refs y estados
 const [streamingState, setStreamingState] =
-  useState<'empty'|'streaming'|'cancelling'>('empty');
+  useState<'empty'|'streaming'|'cancelling'>('empty');

 const pendingDoneResolvers = useRef<(() => void)[]>([]);
diff
Copiar
@@  // handler de eventos entrantes del WebSocket D-ID
   switch (event) {
     case 'stream/started':
       setStreamingState('streaming');
       break;
     case 'stream/done':
-      status = 'done';
-      setStreamingState('empty');          // antes estaba m√°s abajo
+      status = 'done';
+      setStreamingState('empty');          // üî• actualiza de inmediato
+
+      // Libera promesas que esperaban el 'done'
+      pendingDoneResolvers.current.forEach(r => r());
+      pendingDoneResolvers.current = [];
       break;
     case 'stream/error':
       setStreamingState('empty');
       break;
diff
Copiar
@@  // helper sem√°foro REAL
-function waitForRealDone(timeout = 1200): Promise<void> {
-  return new Promise((resolve) => {
-    let done = false;
-    const tid = setTimeout(() => {
-      if (!done) resolve();        // fallback
-    }, timeout);
-
-    pendingDoneResolvers.current.push(() => {
-      done = true;
-      clearTimeout(tid);
-      resolve();
-    });
-  });
+function waitForRealDone(): Promise<void> {
+  // ‚è© Si YA no estamos ‚Äústreaming‚Äù, resuelve en el acto
+  if (streamingStateRef.current !== 'streaming') return Promise.resolve();
+
+  return new Promise(resolve => {
+    pendingDoneResolvers.current.push(resolve);
+  });
 }
diff
Copiar
@@  // cancelaci√≥n
   const cancelCurrentStream = useCallback(async (): Promise<void> => {
-    if (!currentStreamIdRef.current || cancellingRef.current) return;
+    if (!currentStreamIdRef.current
+        || cancellingRef.current
+        || streamingState !== 'streaming') {
+      console.log('[cancel] No hay stream activo; omite.');
+      return;
+    }
(resto permanece igual: stop tracks, close PC, DELETE y luego await waitForRealDone())

2-B Verificaci√≥n antes de mandar texto (sendStreamText o equivalente)
ts
Copiar
if (cancellingRef.current || streamingState !== 'empty') {
  console.warn('[send] Stream todav√≠a activo o cancelando, espera‚Ä¶');
  return;
}
3. Flujo resultante (tiempos reales)
pgsql
Copiar
stream/started
chat/answer
stream/done          ‚Üí   setStreamingState('empty')
                       (usuario a√∫n no ha interrumpido)
[User hits interrupt] ‚Üí  handleInterrupt()
  ‚îî‚îÄ streamingState !== 'streaming'  ‚Üí  NO cancel(), NO abort()
  ‚îî‚îÄ sendStreamText() permitido      ‚Üí  stream/started (nuevo)
Si el usuario interrumpe mientras el bot sigue hablando:

bash
Copiar
stream/started
INTERRUPT
  ‚îú‚îÄ abort LLM
  ‚îú‚îÄ cancelCurrentStream()  ‚úì  (ahora streamingState='cancelling')
  ‚îú‚îÄ waitForRealDone() bloquea
[WebSocket] stream/done
  ‚îî‚îÄ resolve()  ‚Üí streamingState='empty'
sendStreamText() se desbloquea
stream/started (nuevo)
4. Resultado esperado
Sin ‚ÄúManual interrupt‚Äù fantasma cuando el stream ya hab√≠a terminado.

stream/done siempre llega antes del siguiente stream/started.

No vuelve a aparecer el timeout de waitForRealDone.

El avatar se corta visualmente y la l√≥gica backend queda limpia.

Con esta sincronizaci√≥n inmediata entre el evento de WebSocket y tu estado local, eliminas la √∫ltima carrera y estabilizas la cadena completa de interrupci√≥n‚Äìreinicio.










Herramientas


