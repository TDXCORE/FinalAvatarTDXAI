### üîé Causa real del **timeout que no desaparece**

Despu√©s de revisar la documentaci√≥n p√∫blica de **D-ID ‚Äúclips/stream‚Äù** y varios repos open-source (ej. `d-id/live-streaming-demo`) encontramos que:

1. Con el endpoint `DELETE /streams/{id}` la API **no** env√≠a siempre un evento `stream/done` por WebSocket.
   *Para muchos planes s√≥lo devuelve **204** por HTTP y cierra los SRTP pipes; el socket puede quedarse silencioso.*
2. El √∫nico mensaje de cierre que a veces llega es `stream/error` (si fall√≥) o un `RTC disconnect`, no un ‚Äúdone‚Äù.

Por eso tu `waitForRealDone()` **siempre dispara el timeout**: est√°s esperando un evento que D-ID no garantiza.

---

## üõ†Ô∏è C√≥mo debe comportarse la cancelaci√≥n

| Paso                                             | Qu√© usar como ‚Äúconfirmaci√≥n‚Äù                 | Por qu√©                                                            |
| ------------------------------------------------ | -------------------------------------------- | ------------------------------------------------------------------ |
| 1. `DELETE /streams/{id}`                        | **El 204/200 HTTP** devuelto                 | Es la √∫nica se√±al contractual de que D-ID acept√≥ cortar el stream. |
| 2. Esperar 100‚Äì150 ms (m√°x)                      | *Opcional* ‚Äì deja que el backend cierre SRTP | Evita paquetes rezagados, pero no dependas de WebSocket.           |
| 3. `stopAllRemoteTracks()` + `pc.close()`        | Cierra v√≠deo local                           | Garantiza que el avatar se congele.                                |
| 4. `setStreamingState('empty')` ‚Üí `flushQueue()` | Reanuda el ciclo                             | No hay m√°s esperas ni re-connect si el DELETE fue 204.             |

El ‚Äúre-connect‚Äù s√≥lo se necesita **si el DELETE falla** (4xx/5xx) o el WebSocket ya est√° cerrado.

---

## üöß Cambios m√≠nimos en tu c√≥digo

### 1. Simplifica `cancelCurrentStream()`

```ts
const cancelCurrentStream = useCallback(async () => {
  if (!currentStreamIdRef.current || cancellingRef.current) return;
  cancellingRef.current = true;
  setStreamingState('cancelling');

  try {
    const res = await fetch(`${DID_API}/streams/${currentId}`, {
      method: 'DELETE',
      headers: { Authorization: `Bearer ${apiKey}` },
    });

    // ‚úÖ 204 o 200 = √©xito
    if (res.ok) {
      await new Promise(r => setTimeout(r, 120));   // 120 ms grace
    } else {
      throw new Error(`DELETE failed ${res.status}`);
    }
  } catch (err) {
    console.error('[cancel] HTTP error, will reconnect', err);
    markNeedsReconnect();        // ‚Üê tu l√≥gica actual de back-off
  } finally {
    stopAllRemoteTracks();       // corta v√≠deo local
    peerConnectionRef.current?.close();
    peerConnectionRef.current = null;

    currentStreamIdRef.current = null;
    pendingDoneResolvers.current = [];   // limpia promesas
    setStreamingState('empty');
    cancellingRef.current = false;
  }
}, [apiKey]);
```

### 2. Borra `waitForRealDone()`

Ya no necesitas escucharlo; d√©jalo √∫nicamente para planes Enterprise donde ‚Äúdone‚Äù existe, pero **no bloquees**.

```ts
//  if (listenDoneEvents) await waitForRealDone(ws);
```

Pon `listenDoneEvents = false` por defecto.

### 3. Manten la cola ‚Äú√∫ltimo-gana‚Äù

Sigue usando `pendingMsgRef.current` y el buffer de 200 ms tras `stream/ready` antes de `flushPendingMessage()`.

---

## ‚úÖ Resultado esperado

```
stream/started
INTERRUPT
  ‚Ü≥ DELETE /streams/A  (204 en 50-80 ms)
  ‚Ü≥ wait 120 ms
  ‚Ü≥ stopTracks + pc.close()
  ‚Ü≥ state='empty'
  ‚Ü≥ flush queue ‚Üí stream/started B
```

Ya **no aparecer√°** `[waitForRealDone] timeout`, no tendr√°s reconexiones innecesarias, y el avatar reproducir√° siempre la √∫ltima respuesta del LLM tras cada interrupci√≥n.

Haz una prueba con 10 interrupciones seguidas: deber√≠as ver un `DELETE` y, \~300 ms despu√©s, un `stream/started` nuevo, sin ‚Äúneeds-reconnect‚Äù en el medio.
