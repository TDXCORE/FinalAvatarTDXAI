or quÃ© sigue apareciendo â€œTimeout waiting for stream readyâ€
La segunda vez que llamas a init-stream no incluyes el payload completo (al menos session_id y driver_url).
D-ID descarta el mensaje silenciosamente y nunca envÃ­a el evento stream/ready; tu waitForReady() agota el tiempo.

ğŸ›  Correcciones exactas en useWebRTC.ts
A continuaciÃ³n copio el diff mÃ­nimo.
Si tu hook ya tiene variables con otros nombres, solo ajusta los identificadores.

ts
Copiar
/* ---------------- helpers ---------------- */
function buildInitStreamPayload() {
  return {
    session_id : sessionIdRef.current,      // â† obligatorio
    driver_url : config.driverUrl,          // p. ej. "bank://lively"
    voice_id   : config.voiceId             // si usas ElevenLabs
  };
}

/* ------------- sendStreamText ------------- */
export async function sendStreamText(
  text: string,
  abortCtrl?: AbortController
) {
  await ensureSocketOpen(config);

  /* 1. Cierra stream anterior */
  if (streamIdRef.current) {
    wsRef.current!.send(JSON.stringify({
      type: 'delete-stream',
      payload: { session_id: sessionIdRef.current, stream_id: streamIdRef.current }
    }));
    streamIdRef.current   = null;
    isStreamReady.current = false;
  }

  /* 2. Crea uno nuevo con payload completo */
  wsRef.current!.send(JSON.stringify({
    type   : 'init-stream',
    payload: buildInitStreamPayload()       // ğŸ‘ˆ aquÃ­ va el session_id + driver
  }));

  /* 3. Espera stream/ready */
  await waitForReady();                     // resolverÃ¡ cuando onmessage lo capture

  /* 4. Ahora sÃ­ envÃ­as el texto */
  wsRef.current!.send(JSON.stringify({
    type   : 'stream-text',
    payload: {
      session_id: sessionIdRef.current,
      stream_id : streamIdRef.current,      // lo guardas en onmessage
      text,
      numResults: 1
    }
  }));

  if (abortCtrl) bindAbort(abortCtrl);      // tu lÃ³gica existente
}
Handler onmessage (aÃ±ade o verifica)
ts
Copiar
ws.onmessage = (e) => {
  const msg = JSON.parse(e.data);

  if (msg.type === 'stream/ready') {
    streamIdRef.current   = msg.streamId;   // ğŸ‘ˆ GUARDA el nuevo id
    isStreamReady.current = true;
    return;                                 // â† ahora waitForReady() resuelve
  }

  if (msg.type === 'stream/started')  isStreamReady.current = false;
  if (['stream/done','stream/stopped','stream/error'].includes(msg.type))
    isStreamReady.current = true;
};
âœ”ï¸ QuÃ© comprobar despuÃ©s
En el log, justo despuÃ©s de init-stream debe aparecer:

arduino
Copiar
stream/ready
con un streamId nuevo.

A continuaciÃ³n verÃ¡s:

bash
Copiar
sendStreamText called with: â€¦
stream/started
stream/done
para cada turno, sin mÃ¡s timeouts.

Si interrumpes al avatar, observarÃ¡s:

bash
Copiar
stream-interrupt â†’ stream/stopped â†’ stream/ready
y el siguiente turno seguirÃ¡ fluido.

Aplica estas lÃ­neas, guarda y prueba enviando cuatro o cinco mensajes: el avatar debe responderlos todos sin bloquearse.








