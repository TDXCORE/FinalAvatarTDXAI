### Re-evaluaci√≥n de la soluci√≥n de reconexi√≥n ICE

*(garantizando compatibilidad con el resto de tu c√≥digo y sin romper dependencias)*

---

## 1. Objetivo

* **Restablecer** audio/v√≠deo cuando `iceConnectionState` pase a `disconnected` o `failed`.
* **No duplicar** l√≥gicas ya existentes (disconnect / connect / onTrack).
* **Evitar efectos colaterales**: conservar hooks, refs y AbortControllers activos.

---

## 2. Cambios m√≠nimos y seguros

> **S√≥lo tocaremos `useWebRTC.ts`**.
> Nada en UI, hooks de LLM, VAD, ni l√≥gica de avatar se modifica.

### 2.1. A√±ade una referencia a la configuraci√≥n

```ts
// üîù cerca de los dem√°s useRef
const apiConfigRef = useRef<any>(null);
```

En la funci√≥n `connect(apiConfig)` **guarda** la config:

```ts
apiConfigRef.current = apiConfig;   // ‚¨ÖÔ∏è nueva l√≠nea
```

*No afecta a las llamadas existentes: `connect()` sigue recibiendo el objeto*.

---

### 2.2. Refactor de `onIceConnectionStateChange`

```ts
const onIceConnectionStateChange = useCallback(async () => {
  const pc = peerConnectionRef.current;
  if (!pc) return;

  const state = pc.iceConnectionState;
  setIceConnectionState(state);

  /* 1Ô∏è‚É£  primero intenta restartIce (r√°pido y sin renegociar) */
  if (state === 'disconnected') {
    console.warn('üîÑ ICE disconnected ‚Äì trying restartIce');
    try {
      await pc.restartIce();
      return;                       // üéâ se recuper√≥, no hacemos m√°s
    } catch {
      console.warn('restartIce() not supported or failed');
    }
  }

  /* 2Ô∏è‚É£  reconexi√≥n completa s√≥lo si restartIce no funcion√≥  */
  if (state === 'failed' || state === 'disconnected') {
    console.warn('‚ùå ICE', state, '‚Äì reconnecting WebRTC');

    // üîí evita doble reconexi√≥n
    if (connectionStateRef.current === 'reconnecting') return;
    setConnectionState('reconnecting');

    // a) Limpia controladores vivos
    didAbortController.current?.abort();
    didAbortController.current = null;

    // b) Cierra la conexi√≥n actual
    await disconnect();             // tu funci√≥n existente

    // c) Peque√±o respiro para liberar puertos
    await new Promise(r => setTimeout(r, 800));

    // d) Reconecta con la misma config
    if (apiConfigRef.current) {
      await connect(apiConfigRef.current);
      setConnectionState('connected');
    } else {
      console.error('No apiConfig ‚Äì manual reconnect needed');
      setConnectionState('needs-reconnect');
    }
  }
}, [disconnect, connect]);
```

**Por qu√© es seguro**

* No cambias la signatura de callbacks existentes.
* Usa `restartIce()` cuando el navegador lo soporta (Chrome 111+, Edge, Opera) ‚áí reconexi√≥n ‚Äúinvisible‚Äù.
* Solo llama a `disconnect()`/`connect()` cuando es imprescindible.
* Controla el estado con `connectionStateRef` para no disparar reconexiones simult√°neas.

---

### 2.3. `onTrack` ya es compatible

Aseg√∫rate de tener:

```ts
peerConnection.ontrack = (e) => {
  const stream = e.streams[0];
  if (videoRef.current && stream) {
    videoRef.current.srcObject = stream;
    videoRef.current.play().catch(() => {});
  }
};
```

> No hace falta tocarlo: al crear un `RTCPeerConnection` nuevo siempre disparar√° `ontrack`.

---

### 2.4. Sin cambios en otras dependencias

* `disconnect()` y `connect()` ya existen y limpian/crean el WebSocket & PC ‚Üí no se duplican.
* **Api**: no introduces imports nuevos.
* **AbortControllers**: solo los cancelas si se reconecta (buena pr√°ctica).
* **UI**: `setConnectionState('reconnecting' | 'connected')` usa los mismos valores que ya manejas en `ControlPanel`.

---

## 3. Prueba de humo (manual)

1. **Env√≠a 3-4 mensajes**: debe o√≠rse y verse el avatar en todos.
2. En la pesta√±a *Network ‚ûú WebRTC* de Chrome devtools, pulsa **‚ÄúForce Disconnect‚Äù**.

   * Ver√°s `üîÑ ICE disconnected ‚Äì trying restartIce`.
   * Si `restartIce` funciona, el v√≠deo contin√∫a sin cortes.
   * Si no, aparecer√° el log ‚Äúreconnecting WebRTC‚Äù y, tras \~1 s, el clip vuelve a escucharse.
3. Verifica que el indicador de UI pase de ***Reconnecting ‚Üí Connected*** autom√°ticamente.

---

## 4. Checklist de compatibilidad

| Componente                    | Impacto                                                             | Acci√≥n necesaria |
| ----------------------------- | ------------------------------------------------------------------- | ---------------- |
| **LLM / VAD**                 | Ninguno                                                             | N/A              |
| **useLLM**                    | Controlador se aborta solo durante reconexi√≥n (no rompe flujo).     | Nada             |
| **AvatarVideo**               | Recibe nueva pista v√≠a `ontrack`.                                   | Nada             |
| **useVoiceActivityDetection** | Sin cambios.                                                        | Nada             |
| **Barge-in / abortTurn**      | Funciona igual; `didAbortController` se limpia antes de reconectar. | Nada             |

---

## Conclusi√≥n

Implementando **solo** los fragmentos anteriores:

* Evitas pantallas negras y p√©rdida de audio.
* Mantienes intactas las dependencias.
* Minimiza reconexiones redundantes gracias a `restartIce`.

Puedes proceder con seguridad. Si durante test ves ICE ‚Äúfailed‚Äù repetitivo, aumenta el delay `setTimeout(r, 1500)` para dar margen al sistema operativo.
