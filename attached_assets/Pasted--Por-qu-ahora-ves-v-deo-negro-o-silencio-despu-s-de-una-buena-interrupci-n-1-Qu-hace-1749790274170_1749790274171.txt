### üß© Por qu√© ahora ves v√≠deo negro (o silencio) despu√©s de una buena interrupci√≥n

1. **Qu√© hacemos en la interrupci√≥n**

   ```ts
   peerConnectionRef.current
     .getReceivers()
     .forEach(r => r.track?.stop());   // ‚Üê track.stop()
   videoRef.current.srcObject = null;
   ```

   Eso pone cada `MediaStreamTrack` remoto en estado **`ended`** de forma **irrevocable** (WebRTC spec ¬ß6.2).
   Una vez marcado `ended`, **ese mismo objeto** no puede volver a transportar frames.

2. **Qu√© hace D-ID**
   Cuando env√≠as el siguiente texto, D-ID **reusa el mismo transceiver** y vuelca los paquetes RTP en el *mismo* `RTCRtpReceiver`.
   ‚Äì Chrome/Edge no crean un track nuevo si el anterior ya existe.
   ‚Äì Como tu track est√° ‚Äúmuerto‚Äù, los frames llegan, pero la canalizaci√≥n JS ‚Üí `<video>` qued√≥ rota ‚áí pantalla negra / silencio.

3. **Por qu√© los eventos (`stream/started`, `chat/partial`) s√≠ llegan**
   Esos viajan por **WebSocket**. El backend confirma que el TTS arranca, pero el canal de medios que llega al navegador ya no tiene un `MediaStreamTrack` v√°lido al que engancharse.

---

## C√≥mo deber√≠a funcionar (sin cambiar nada m√°s)

| En la interrupci√≥n                                       | En vez de                    | Haz                                                                                                        |
| -------------------------------------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------- |
| Parar los tracks                                         | `track.stop()` (‚ùå)           | **a)** No hagas nada al track <br>**o** <br>**b)** `track.enabled = false` si quieres ‚Äúmutear‚Äù localmente. |
| Limpiar `<video>`                                        | `srcObject = null` est√° bien | El primer frame nuevo volver√° a asignarse en `ontrack`.                                                    |
| Deja que D-ID env√≠e el mismo track y Chrome lo ‚Äúreviva‚Äù. | ‚Äì                            |                                                                                                            |

---

### Qu√© pasa con los **receivers**

* **Antes de la interrupci√≥n**

  ```
  RTCRtpReceiver#123 ‚Üí MediaStreamTrack#A (live)
  ```
* **Haces `track.stop()`**

  ```
  #A ‚Üí readyState = 'ended'
  ```
* **Nuevo turno, mismo transceiver**

  ```
  RTP paquetes ‚Üí Receiver#123 ‚Üí Track#A (ended) ‚ûú descartados
  ```

Si **no** haces `stop()`, el track #A sigue vivo; Chrome simplemente vuelve a entregar frames y el `<video>` se actualiza.

---

## Pasos para comprobarlo

1. **Revertir temporalmente** la l√≠nea `track?.stop()`.
2. Mantener todo lo dem√°s igual.
3. Interrumpir ‚Üí deber√≠a reaparecer v√≠deo/voz en el siguiente `stream/started`.

Si necesitas silenciar el avatar durante los 120 ms de gracia, usa:

```ts
receiver.track.enabled = false;
setTimeout(() => receiver.track.enabled = true, 120);
```

Esto no lo marca como `ended`.

---

### Resumen

* `track.stop()` es definitivo para **tracks remotos**: mata la ruta de medios.
* Mant√©n la `RTCPeerConnection` viva y **no** invoques `stop()`; basta con vaciar el `<video>` o deshabilitar el track.
* El resto de tu flujo (delete-stream, grace 120 ms, estado ='empty') ya es correcto. S√≥lo quita esa llamada y el avatar reproducir√° el nuevo v√≠deo inmediatamente.
