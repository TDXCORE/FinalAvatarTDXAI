Lo que todavía provoca el bloqueo tras el primer turno
Falta un streamId válido antes de mandar stream-text
El hook ahora detecta “D-ID session not ready – missing: { streamId:false }”.
Eso ocurre porque después de hacer delete-stream no esperas el nuevo init-stream → stream/ready, ni guardas el nuevo streamId. Resultado: envías texto sin un streamId abierto.

Aún existe código que fuerza stream/ready manualmente
El log muestra “forcing stream/ready”. Esto oculta el error pero deja el WebSocket desincronizado.

Todavía se borra didAbortController después de crear el nuevo clip
En onResponse el bloque didAbortController.current.abort(); está bien, pero justo después se crea controller y se asigna; luego un efecto aparte lo vuelve a poner a null antes de que empiece el segundo clip.

Cambios exactos a aplicar
1. useWebRTC.ts
ts
Copiar
// 1️⃣ Guarda el nuevo streamId cuando D-ID responde a init-stream
ws.onmessage = (e) => {
  const msg = JSON.parse(e.data);
  if (msg.type === 'stream/ready') {
    streamIdRef.current = msg.streamId;   // <-- GUARDA aquí
    isStreamReady.current = true;
  }
  if (msg.type === 'stream/started') {
    isStreamReady.current = false;        // bloquea hasta done/stopped
  }
  if (['stream/done','stream/stopped','stream/error'].includes(msg.type)) {
    isStreamReady.current = true;
  }
};

// 2️⃣ En sendStreamText() elimina cualquier “forcing stream ready”
if (!isStreamReady.current) {
  console.warn('⏳ Stream busy');
  return;
}

// 3️⃣ Después de delete-stream ESPERA al nuevo ready
if (streamIdRef.current) {
  wsRef.current!.send(JSON.stringify({ type:'delete-stream', streamId:streamIdRef.current }));
  streamIdRef.current = null;
  isStreamReady.current = false;
  await waitForReady();   // función que resuelve al recibir nuevo ready
}
ts
Copiar
async function waitForReady(timeout = 4000) {
  return new Promise((resolve, reject) => {
    const start = Date.now();
    const check = () => {
      if (isStreamReady.current) return resolve(true);
      if (Date.now() - start > timeout) return reject(new Error('ready timeout'));
      requestAnimationFrame(check);
    };
    check();
  });
}
2. ConversationalAvatar.tsx
ts
Copiar
// Limpia abortController SOLO en el efecto cuando clip termina
useEffect(() => {
  if (['done','error','stopped'].includes(streamEvent)) {
    didAbortController.current = null;   // ✅
  }
}, [streamEvent]);

// ⚠️ NO lo limpies en ningún otro lugar (borra duplicados).
3. Elimina cualquier línea “forcing stream/ready state”
Busca en todo el proyecto texto como:

ts
Copiar
console.log('forcing stream/ready');
setIsStreamReady(true);
y bórralo.

Resultado esperado
Cada turno: init-stream → stream/ready → stream-text → stream/started → stream/done.

El log ya no muestra “session not ready” ni “forcing stream ready”.

El avatar responde indefinidamente, con o sin interrupciones.

Realiza estos tres grupos de cambios, reinicia y prueba mandando 4-5 mensajes seguidos: debe contestar todos.










Herramientas



