 Tu diagn√≥stico es correcto: mientras el RTCPeerConnection siga vivo, el <video> contin√∫a mostrando el √∫ltimo frame aunque D-ID ya haya recibido el DELETE.
Aqu√≠ tienes un parche exacto y algunas recomendaciones extra para impedir nuevas carreras.

1. Diff ‚Äì client/src/hooks/useWebRTC.ts
diff
Copiar
@@
-  const cancelCurrentStream = useCallback(async (): Promise<void> => {
-    if (!currentStreamIdRef.current || cancellingRef.current) return;
-    cancellingRef.current = true;
+  const cancelCurrentStream = useCallback(async (): Promise<void> => {
+    if (!currentStreamIdRef.current || cancellingRef.current) return;
+    cancellingRef.current = true;
+
+    // ‚èπÔ∏è 1) Det√©n audio + video YA mismo
+    if (peerConnectionRef.current) {
+      peerConnectionRef.current.getReceivers()
+        .forEach(r => r.track?.stop());
+      peerConnectionRef.current.close();
+      peerConnectionRef.current = null;
+    }
+
+    // üîÑ Limpia el elemento <video> para que no quede congelado
+    if (remoteVideoRef.current) {
+      remoteVideoRef.current.srcObject = null;
+    }
 
-    try {
+    try {
       await fetch(`${DID_API}/streams/${currentStreamIdRef.current}`, {
         method: 'DELETE',
         headers: { Authorization: `Bearer ${apiKey}` },
       });
-      await waitForStreamDone();             // üïí espera confirmaci√≥n
+      await waitForStreamDone();             // üïí a√∫n esperamos para no saturar D-ID
     } catch (err) {
       console.error('Error cancelling stream', err);
     } finally {
       currentStreamIdRef.current = null;
       setStreamingState('empty');
       cancellingRef.current = false;
     }
   }, [apiKey]);
Aseg√∫rate de que peerConnectionRef y remoteVideoRef correspondan a tus refs reales.

2. Diff ‚Äì client/src/pages/ConversationalAvatar.tsx
diff
Copiar
-  const handleInterrupt = async () => {
-    if (streamingState !== 'streaming') return;
-    abortControllerRef.current?.abort?.();          // corta LLM
-    await cancelCurrentStream();                    // espera cierre
-    // ‚Ä¶procedes con el nuevo mensaje
-  };
+  const handleInterrupt = async () => {
+    if (streamingState !== 'streaming' || cancellingRef.current) return;
+    abortControllerRef.current?.abort?.();          // corta LLM inmediato
+    await cancelCurrentStream();                    // conexi√≥n fuera
+    // ahora s√≠ env√≠as el nuevo texto (o dejas que VAD dispare STT)
+  };
3. Bloqueo en el env√≠o
En cualquier funci√≥n que cree un nuevo stream (p. ej. sendStreamText()):

ts
Copiar
if (cancellingRef.current || streamingState !== 'empty') {
  console.warn('Stream todav√≠a cancel√°ndose, omite env√≠o.');
  return;
}
4. Orden de eventos esperados
bash
Copiar
stream/started           (avatar habla)
INTERRUPT
  ‚Ü≥ abort LLM            (instant√°neo)
  ‚Ü≥ stop tracks + close PC
  ‚Ü≥ DELETE /streams/{id}
[video desaparece]        (t = +0‚Äâ‚Äì‚Äâ50 ms)
stream/done (llega tarde, ignorado)
[VAD sigue capturando]    (nuevo texto se detecta)
stream/started (nuevo)    (sin solaparse)
5. Checklist r√°pido
Visual: el avatar se congela < 100 ms tras la interrupci√≥n.

Consola: no hay duplicates de stream/started sin un stream/done previo.

Spameo: varios INT seguidos no arrojan warnings de InvalidStateError (el flag lo evita).

Uso de CPU: getReceivers().forEach(track.stop()) libera el decodificador inmediatamente.

Con esto el ciclo queda limpio: se cierra la conexi√≥n WebRTC en cuanto detectas la interrupci√≥n y el v√≠deo se esfuma al instante, eliminando cualquier superposici√≥n entre el stream viejo y el nuevo.










Herramientas



ChatGP