Tu diagn√≥stico es correcto: el `currentStreamIdRef` (o la variable equivalente que usas para saber si hay un stream activo) debe volver a llenarse en cuanto obtienes los IDs del nuevo turno; de lo contrario, las siguientes interrupciones quedan bloqueadas por el guard que comprueba ‚Äú¬øhay stream en curso?‚Äù.

---

## Pasos precisos para cerrar el bug

| Paso                                                          | Qu√© cambia                                                                                                                                                                                                                                                                                           | Por qu√©                                                                                                                                                                  |                                                                                                         |
| ------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------- |
| **1. Asigna el nuevo `streamId` al ref**                      | Dentro del handler donde parseas la respuesta de **POST /streams** o el mensaje `init-stream` del WebSocket:  `ts const { id: newStreamId, sessionId: newSessionId } = data; setStreamId(newStreamId); setSessionId(newSessionId); currentStreamIdRef.current = newStreamId;   // üëà l√≠nea cr√≠tica ` | El guard de `handleInterrupt` se basar√° en este ref para decidir si debe cancelar.                                                                                       |                                                                                                         |
| **2. Borra el ref s√≥lo despu√©s** de enviar el `delete-stream` | Mant√©n la l√≠nea que pone `currentStreamIdRef.current = null;` **en el `finally`** de `cancelCurrentStream`, pero nunca antes.                                                                                                                                                                        | As√≠ garantizas que durante los 120 ms de gracia siga consider√°ndose ‚Äúhay stream‚Äù, evitando cancels repetidos y asegurando que el siguiente POST lo sobrescriba de nuevo. |                                                                                                         |
| **3. Sincroniza estado y ref (si fueran distintos)**          | Siempre que hagas `setStreamId(x)` haz tambi√©n `currentStreamIdRef.current = x`. Puedes envolverlo:  \`\`\`ts function updateStreamId(id: string                                                                                                                                                     | null) { setStreamId(id); currentStreamIdRef.current = id; } \`\`\`                                                                                                       | Evitas que un ref se desfas-e del estado React cuando alg√∫n cambio se haga desde otro punto del c√≥digo. |
| **4. Verifica que s√≥lo el delete pone el streamId a `null`**  | En el flujo normal (stream/done sin interrupci√≥n) **no** borres el ref; eso lo decide D-ID. D√©jalo nulo s√≥lo cuando cancelas t√∫.                                                                                                                                                                     | As√≠, si el usuario interrumpe justo al final de una respuesta, el guard a√∫n ve un `streamId` y procede.                                                                  |                                                                                                         |

---

### Checklist r√°pido de prueba

1. **Interrupci√≥n #1**

   * Ves `currentStreamIdRef = strm_ABC` al entrar en `handleInterrupt`.
   * Despu√©s del grace de 120 ms, consola muestra `‚Ä¶ ref=null, state='empty'`.

2. **Nuevo POST /streams**

   * Log: `updateStreamId(strm_DEF)`.

3. **Interrupci√≥n #2**

   * `[INT-check] streamId: strm_DEF ‚Ä¶`
   * Se ejecuta `cancelCurrentStream` sin salirse del guard.
   * Se repite el ciclo indefinidamente sin reconexi√≥n ni v√≠deo negro.

Una vez ese ref se sincronice correctamente, tendr√°s interrupciones ilimitadas tanto por texto como por voz.
