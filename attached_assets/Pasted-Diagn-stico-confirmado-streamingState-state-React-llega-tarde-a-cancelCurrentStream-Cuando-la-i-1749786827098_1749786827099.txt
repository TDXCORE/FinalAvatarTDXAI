Diagn√≥stico confirmado
streamingState (state React) llega tarde a cancelCurrentStream().
Cuando la interrupci√≥n entra, el flag (‚Äúbot talking‚Äù) a√∫n es true, pero en el micro-tick siguiente React ya program√≥ un nuevo render y el valor dentro del closure cambi√≥.
Resultado: la cl√°usula

ts
Copiar
if (streamingState !== 'streaming') return;
se eval√∫a con el estado viejo y la cancelaci√≥n se salta.

üîß Correcci√≥n: usa un ref inmutable al tick de JS
Crea un ref que siempre contenga el valor actual ‚Äîsin esperar render.

Actual√≠zalo cada vez que cambie el estado (o directamente dentro del handler de eventos).

Consulta el ref (no el state) en cancelCurrentStream() y en cualquier guard que dependa de ‚Äúbot hablando‚Äù.

1. Parchado de useWebRTC.ts
diff
Copiar
@@
-const [streamingState, setStreamingState] =
-  useState<'empty'|'streaming'|'cancelling'>('empty');
+const [streamingState, _setStreamingState] =
+  useState<'empty'|'streaming'|'cancelling'>('empty');
+const streamingStateRef = useRef<'empty'|'streaming'|'cancelling'>('empty');

+function setStreamingState(next: 'empty'|'streaming'|'cancelling') {
+  streamingStateRef.current = next;   // üëà ref actualizado SINcrono
+  _setStreamingState(next);           // estado React (async)
+}

@@  // onStreamEvent
   switch (event) {
     case 'stream/started':
-      setStreamingState('streaming');
+      setStreamingState('streaming');  // actualiza ref + state
       break;
     case 'stream/done':
-      setStreamingState('empty');
+      setStreamingState('empty');
       /* ‚Ä¶libera promesas‚Ä¶ */
       break;
2. Usa el ref en las verificaciones cr√≠ticas
diff
Copiar
- if (!currentStreamIdRef.current
-     || cancellingRef.current
-     || streamingState !== 'streaming') {
+ if (!currentStreamIdRef.current
+     || cancellingRef.current
+     || streamingStateRef.current !== 'streaming') {
       console.log('[cancel] No hay stream activo; omite.');
       return;
 }
Y en handleInterrupt (o el VAD hook):

ts
Copiar
if (streamingStateRef.current !== 'streaming' || cancellingRef.current) return;
3. Opcional: helper useLatest<T>(value)
Si prefieres un patr√≥n reutilizable:

ts
Copiar
function useLatest<T>(val: T) {
  const ref = useRef(val);
  ref.current = val;
  return ref;
}
ts
Copiar
const streamingStateRef = useLatest(streamingState);
Pero en este caso ya estamos envolviendo el setter, que es incluso m√°s seguro.

üöÄ Resultado esperado
Interrupci√≥n ‚Üí cancelCurrentStream() consulta streamingStateRef.current === 'streaming' ‚Üí entra correctamente.

Tracks remotos se stop(), peerConnection.close() y <video> se limpia inmediatamente.

No vuelves a ver [cancel] No hay stream activo; omite. cuando el avatar realmente est√° hablando.

Las interrupciones sobre streams ya terminados siguen ignor√°ndose (porque el ref dir√° 'empty').

Con el ref eliminamos la carrera entre el ciclo de vida React y el flujo WebRTC, consiguiendo una sincronizaci√≥n precisa sin depender de timeouts.