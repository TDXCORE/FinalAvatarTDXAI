Arreglo de timing: espera a que D-ID confirme el corte antes de lanzar el siguiente stream
(y elimina el mensaje â€œConversaciÃ³n interrumpidaâ€)

1. QuÃ© estÃ¡ pasando
scss
Copiar
INTERRUPT
â”‚
â”œâ”€ abortCurrentRequest()               â†’ LLM se detiene âœ…
â”œâ”€ cancelCurrentStream()  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                    â””â”€ (via WebSocket) tarda 50-80 ms
â””â”€ processUserMessage() (inmediato)   â†âŒ se dispara ANTES de que D-ID procese el DELETE
Resultado: el stream nuevo comienza mientras el antiguo aÃºn vive â†’ vÃ­deo nunca se corta.

2. Plan mÃ­nimo
cancelCurrentStream() devuelve una promesa que se resuelve cuando llega stream/done o tras un timeout (fallback 800 ms).

handleInterrupt() se hace async y await esa promesa antes de llamar a processUserMessage().

Remueve el mensaje â€œConversaciÃ³n interrumpidaâ€¦â€.

Introduce un flag isCancelling para bloquear cualquier otro envÃ­o mientras se espera.

3. Parche (git diff)
diff
Copiar
diff --git a/client/src/hooks/useWebRTC.ts b/client/src/hooks/useWebRTC.ts
@@
-  const [streamingState, setStreamingState] = useState<'empty'|'streaming'>('empty');
+  const [streamingState, setStreamingState] = useState<'empty'|'streaming'|'cancelling'>('empty');
+  const cancellingRef = useRef(false);

+  // Wait helper:  resolve cuando llega 'stream/done'  o timeout
+  function waitForStreamDone(timeout = 800): Promise<void> {
+    return new Promise((resolve) => {
+      const tid = setTimeout(resolve, timeout);
+      const listener = (event: string) => {
+        if (event === 'stream/done' || event === 'stream/error') {
+          clearTimeout(tid);
+          socket.off('message', listener as any);
+          resolve();
+        }
+      };
+      socket.on('message', listener);        // ğŸ‘ˆ tu wrapper de WS
+    });
+  }

   const cancelCurrentStream = useCallback(async (): Promise<void> => {
     if (!currentStreamIdRef.current || cancellingRef.current) return;
-    try {
+    cancellingRef.current = true;
+    setStreamingState('cancelling');
+    try {
       await fetch(`${DID_API}/streams/${currentStreamIdRef.current}`, {
         method: 'DELETE',
         headers: { Authorization: `Bearer ${apiKey}` },
       });
-    } catch (err) {
+      await waitForStreamDone();             // ğŸ•’ espera confirmaciÃ³n
+    } catch (err) {
       console.error('Error cancelling stream', err);
     } finally {
       currentStreamIdRef.current = null;
-      setStreamingState('empty');
+      setStreamingState('empty');
+      cancellingRef.current = false;
     }
   }, [apiKey]);
diff
Copiar
diff --git a/client/src/components/ConversationalAvatar.tsx b/client/src/components/ConversationalAvatar.tsx
@@
-const handleInterrupt = () => {
-  console.log('ğŸš¨ Manual interrupt detected');
-  abortControllerRef.current?.abort?.();
-  cancelCurrentStream();
-  addConversationMessage('system', 'ConversaciÃ³n interrumpida. ContinÃºa hablando...'); // âŒ confunde
-};
+const handleInterrupt = async () => {
+  console.log('ğŸš¨ Manual interrupt detected');
+  abortControllerRef.current?.abort?.();    // corta LLM
+  await cancelCurrentStream();              // espera a que vÃ­deo pare
+  // ğŸ‘† no agregues mensaje de sistema: UX mÃ¡s limpia
+};
diff
Copiar
diff --git a/client/src/hooks/useVoiceActivityDetection.ts b/client/src/hooks/useVoiceActivityDetection.ts
@@
   if (isCancelling) return;    // ğŸ›¡ï¸ bloquea VAD durante cancelaciÃ³n
(AÃ±ade el isCancelling como prop si lo necesitas, o lee streamingState === 'cancelling' directamente.)

4. Checklist de verificaciÃ³n
Interrumpes â†’ avatar se calla en â‰¤ 200 ms.

Consola muestra orden correcto:

bash
Copiar
â€¦ stream/started
ğŸš¨ Manual interrupt detected
ğŸ—‘ï¸ Cancelling current D-ID stream
stream/done          â† ahora sÃ­ llega antes del stream nuevo
â€¦ stream/started      â† sÃ³lo cuando el anterior acabÃ³
Sin mensaje â€œConversaciÃ³n interrumpidaâ€ en el chat.

Spams rÃ¡pidos de teclado/voz no crean condiciÃ³n de carrera (el flag cancellingRef los bloquea).

Con este pequeÃ±o gate sincrÃ³nico el flujo se hace robusto: siempre paras al avatar antes de arrancar la siguiente respuesta.