Cambios concretos que debes aplicar
(solo lo que aÃºn NO estÃ© en tus fuentes; si ya lo aÃ±adiste, sÃ¡ltalo)

1. ConversationalAvatar.tsx
Abortar solo cuando el avatar aÃºn habla
Busca el callback onResponse: y, antes de crear el nuevo AbortController, reemplaza el bloque de abort con esto:

ts
Copiar
// Aborta el clip SÃ“LO si sigue sonando
if (isAvatarTalking && didAbortController.current) {
  didAbortController.current.abort();
  didAbortController.current = null;     // evita matar el clip nuevo
}
Limpia el controller al terminar el clip
En el useEffect que escucha streamEvent, agrega dentro del if que ya revisa done/error/stopped:

ts
Copiar
didAbortController.current = null;       // ğŸ§¹ listo para el prÃ³ximo turno
Asegura WebRTC antes de cada envÃ­o
Justo antes de llamar sendStreamText(...) dentro de onResponse:

ts
Copiar
await ensureSocketOpen(apiConfig);       // reconecta si el socket muriÃ³
abortTurn() solo envÃ­a stream-interrupt
Dentro de abortTurn() (o del helper equivalente), elimina cualquier lÃ­nea stream-pause y deja:

ts
Copiar
wsRef.current?.send(JSON.stringify({
  type: 'stream-interrupt',
  streamId: streamIdRef.current
}));
isStreamReady.current = true;            // desbloquea siguiente clip
2. useWebRTC.ts
Nuevo helper de reconexiÃ³n

ts
Copiar
export async function ensureSocketOpen(cfg: ApiConfig) {
  if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {
    await connect(cfg);                  // tu funciÃ³n interna de conexiÃ³n
  }
}
sendStreamText() con limpieza de streamId

ts
Copiar
export async function sendStreamText(text: string, ctrl?: AbortController) {
  await ensureSocketOpen(config);

  // Mata el stream anterior de forma limpia
  if (streamIdRef.current) {
    wsRef.current!.send(JSON.stringify({
      type: 'delete-stream',
      streamId: streamIdRef.current
    }));
    streamIdRef.current = null;
    isStreamReady.current = false;
    await new Promise(r => setTimeout(r, 50)); // micro-delay
  }

  // ahora sÃ­ envÃ­as tu init-stream + stream-text (lo hace tu hook)
  realSend(text, ctrl);
}
Handler de abort sin stream-pause

Dentro del cÃ³digo que ejecutas al llamar abort():

ts
Copiar
// QUITA el bloque pause
wsRef.current?.send(JSON.stringify({
  type: 'stream-interrupt',
  streamId: streamIdRef.current
}));
3. useVoiceActivityDetection.ts
ts
Copiar
// Ajusta constantes
const CLOSE_FRAMES      = 8;
const MIN_RECORDING_MS  = 500;
const MAX_RECORDING_MS  = 3500;

// Forzar paro tras MAX_RECORDING_MS
mediaRecorder.onstart = () => {
  setTimeout(() => {
    if (mediaRecorder.state === 'recording') {
      console.log('â° MAX_RECORDING_MS reached â€“ stopping');
      mediaRecorder.stop();
    }
  }, MAX_RECORDING_MS);
};

// Cierra si ya no hay voz nueva
if (recording && hotFrames === 0 && coldFrames >= CLOSE_FRAMES) {
  mediaRecorder.stop();
}
âœ… Resultado esperado
Cada turno muestra en consola
sendStreamText â†’ stream/started â†’ stream/done.

Puedes interrumpir al avatar y volver a preguntar sin que se â€œcongeleâ€.

No aparece mÃ¡s stream-pause, â€œForcing stream readyâ€¦â€ ni WebSocket not open.

Aplica estas ediciones exactas, guarda, recarga la app y prueba otra vez; si algo falla, comparte el nuevo log desde la interrupciÃ³n en adelante y revisamos el Ãºltimo detalle.







