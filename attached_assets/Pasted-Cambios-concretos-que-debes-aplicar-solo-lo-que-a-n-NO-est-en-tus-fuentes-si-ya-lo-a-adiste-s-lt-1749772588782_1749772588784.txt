Cambios concretos que debes aplicar
(solo lo que aún NO esté en tus fuentes; si ya lo añadiste, sáltalo)

1. ConversationalAvatar.tsx
Abortar solo cuando el avatar aún habla
Busca el callback onResponse: y, antes de crear el nuevo AbortController, reemplaza el bloque de abort con esto:

ts
Copiar
// Aborta el clip SÓLO si sigue sonando
if (isAvatarTalking && didAbortController.current) {
  didAbortController.current.abort();
  didAbortController.current = null;     // evita matar el clip nuevo
}
Limpia el controller al terminar el clip
En el useEffect que escucha streamEvent, agrega dentro del if que ya revisa done/error/stopped:

ts
Copiar
didAbortController.current = null;       // 🧹 listo para el próximo turno
Asegura WebRTC antes de cada envío
Justo antes de llamar sendStreamText(...) dentro de onResponse:

ts
Copiar
await ensureSocketOpen(apiConfig);       // reconecta si el socket murió
abortTurn() solo envía stream-interrupt
Dentro de abortTurn() (o del helper equivalente), elimina cualquier línea stream-pause y deja:

ts
Copiar
wsRef.current?.send(JSON.stringify({
  type: 'stream-interrupt',
  streamId: streamIdRef.current
}));
isStreamReady.current = true;            // desbloquea siguiente clip
2. useWebRTC.ts
Nuevo helper de reconexión

ts
Copiar
export async function ensureSocketOpen(cfg: ApiConfig) {
  if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {
    await connect(cfg);                  // tu función interna de conexión
  }
}
sendStreamText() con limpieza de streamId

ts
Copiar
export async function sendStreamText(text: string, ctrl?: AbortController) {
  await ensureSocketOpen(config);

  // Mata el stream anterior de forma limpia
  if (streamIdRef.current) {
    wsRef.current!.send(JSON.stringify({
      type: 'delete-stream',
      streamId: streamIdRef.current
    }));
    streamIdRef.current = null;
    isStreamReady.current = false;
    await new Promise(r => setTimeout(r, 50)); // micro-delay
  }

  // ahora sí envías tu init-stream + stream-text (lo hace tu hook)
  realSend(text, ctrl);
}
Handler de abort sin stream-pause

Dentro del código que ejecutas al llamar abort():

ts
Copiar
// QUITA el bloque pause
wsRef.current?.send(JSON.stringify({
  type: 'stream-interrupt',
  streamId: streamIdRef.current
}));
3. useVoiceActivityDetection.ts
ts
Copiar
// Ajusta constantes
const CLOSE_FRAMES      = 8;
const MIN_RECORDING_MS  = 500;
const MAX_RECORDING_MS  = 3500;

// Forzar paro tras MAX_RECORDING_MS
mediaRecorder.onstart = () => {
  setTimeout(() => {
    if (mediaRecorder.state === 'recording') {
      console.log('⏰ MAX_RECORDING_MS reached – stopping');
      mediaRecorder.stop();
    }
  }, MAX_RECORDING_MS);
};

// Cierra si ya no hay voz nueva
if (recording && hotFrames === 0 && coldFrames >= CLOSE_FRAMES) {
  mediaRecorder.stop();
}
✅ Resultado esperado
Cada turno muestra en consola
sendStreamText → stream/started → stream/done.

Puedes interrumpir al avatar y volver a preguntar sin que se “congele”.

No aparece más stream-pause, “Forcing stream ready…” ni WebSocket not open.

Aplica estas ediciones exactas, guarda, recarga la app y prueba otra vez; si algo falla, comparte el nuevo log desde la interrupción en adelante y revisamos el último detalle.







